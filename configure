#!/usr/bin/env python

import os
import re
import sys

class EnableOption(object):
    def __init__(self, name, help, default=False, disabled="0", enabled="1",
            param=None):
        self.name = name
        self.help = help
        self.disabled = disabled
        self.enabled = enabled
        self.param = name.upper() if param is None else param
        self.setValue(default)

    def setValue(self, value):
        if value == True:
            self.value = self.enabled
        elif value == False:
            self.value = self.disabled
        else:
            self.value = value

    def emitConfigMk(self, output):
        output.write("%s := %s\n" % (self.param, self.value))

config_options = (
  EnableOption("debug", "Enable building with developer debug info",
    default=True),
  EnableOption("optimize", "Enable compiler optimizations",
    default=False, disabled="", enabled="-O3", param="OPTFLAGS"),
  EnableOption("debug-symbols", "Enable debugging symbols",
    default=True, disabled="", enabled="-g", param="DEBUGFLAGS"),
)

env_progs = {
    'CC': ['clang', 'gcc', 'cc'],
    'CXX': ['clang++', 'g++', 'c++'],
    'LLVMCONFIG': ['llvm-config']
}

env_flags = {
    'CFLAGS': '-std=gnu99 -Wall',
    'CXXFLAGS': '-std=c++11 -Wall',
}

def saveEnvironment(env):
    path = env['PATH'].split(':')
    def which(name):
        for p in path:
            if os.path.exists(os.path.join(p, name)):
                return os.path.join(p, name)
        return None
    savedEnv = dict()
    for var in env_progs:
        if var in env:
            savedEnv[var] = env[var]
        else:
            for prog in env_progs[var]:
                val = which(prog)
                if val is not None:
                    savedEnv[var] = val
                    break
            else:
                sys.stderr.write("Cannot find program for %s\n" % var)
                sys.stderr.write("Expected one of %s\n" %
                    ', '.join(env_progs[var]))
                sys.exit(1)
    for var in env_flags:
        if var in env:
            savedEnv[var] = env[var] + ' ' + env_flags[var]
        else:
            savedEnv[var] = env_flags[var]
    return savedEnv

def buildConfigMk(output, options, environ):
    for opt in options:
        opt.emitConfigMk(output)
    for key, val in environ.items():
        output.write("%s := %s\n" % (key, val))

def buildMakefile(relpath, srcdir, objdir):
    outfile = os.path.join(objdir, relpath)[:-3] # Remove .in
    dirpath = os.path.dirname(relpath)

    # Make sure that we are writing to a valid location
    outdir = os.path.dirname(outfile)
    if not os.path.exists(outdir):
        os.makedirs(outdir)

    with open(outfile, 'w') as outfd:
        outfd.write("# This file is autogenerated. DO NOT EDIT\n")
        outfd.write("DEPTH := %s\n" %
            os.path.relpath(objdir, os.path.dirname(outfile)))
        outfd.write("ifndef _top\n")
        outfd.write("include $(DEPTH)/config.mk\n")
        outfd.write("endif\n")
        outfd.write("srcdir := $(topsrcdir)/%s\n" % dirpath)
        outfd.write("objdir := %s\n" % outdir)
        outfd.write("relativedir := %s\n" % dirpath)
        outfd.write("\n")
        with open(os.path.join(srcdir, relpath), 'r') as infd:
            outfd.write(infd.read())
        outfd.write("\n")
        outfd.write("ifndef _top\n")
        outfd.write("include $(topsrcdir)/rules.mk\n")
        outfd.write("endif\n")

def processArguments(objdir, srcdir, arguments):
    objdir = os.path.abspath(objdir)
    srcdir = os.path.abspath(srcdir)

    # Build the options used to do the configure
    opts = dict()
    for opt in config_options:
        opts[opt.name] = opt

    # For every argument, set the value in the config_options directory
    for arg in arguments:
        processArgument(opts, arg)

    # Process the environment lookup
    env = saveEnvironment(os.environ)

    # Find all files to generate in configure
    generated_files = []
    for dirpath, dirnames, filenames in os.walk(srcdir):
        contenders = [f for f in filenames if f == "Makefile.in"]
        generated_files += [os.path.join(dirpath, f) for f in contenders]

    # Output config.mk in the current directory
    with open(os.path.join(objdir, "config.mk"), "w") as configmk:
        configmk.write("# This file is autogenerated. DO NOT EDIT!\n")
        configmk.write("topsrcdir := %s\n" % srcdir)
        configmk.write("topobjdir := %s\n" % objdir)
        configmk.write("allmakefiles := %s\n" % ' '.join(
            os.path.abspath(f) for f in generated_files))
        configmk.write("configflags := %s\n" % ' '.join(arguments))
        buildConfigMk(configmk, opts.values(), env)

    for makefile in generated_files:
        buildMakefile(os.path.relpath(makefile, srcdir), srcdir, objdir)

complexRe = re.compile("--(enable|disable|with|without)-([a-zA-Z0-9_-]+)(=.*)?")
def processArgument(options, arg):
    components = complexRe.match(arg)
    if components is not None:
        # This is a regular kind of argument
        optname = components.group(2)
        try:
            opt = options[optname]
        except KeyError:
            # --enable-some-illegal-option. Ignore it.
            return
        kind = components.group(1)
        if kind == "disable" or kind == "without":
            opt.setValue(False)
        elif kind == "enable" or kind == "with":
            if components.group(3) is not None:
                opt.setValue(components.group(3))
            else:
                opt.setValue(True)
    elif arg == "--help":
        printHelp()
    else:
        sys.stderr.write("Unknown option: " + arg + '\n')
        printHelp()

def printHelp():
    sys.stderr.write("Usage: configure [options]\n")
    sys.stderr.write("Options are one of the following:\n")
    def printOpt(name, message):
        if len(name) > 20:
            sys.stderr.write("  --%s\n" % name)
            sys.stderr.write("    " + " " * 20 + " %s\n" % message)
        else:
            sys.stderr.write("  --%-20s %s\n" % (name, message))
    printOpt("help", "print this message")
    for opt in config_options:
        if type(opt) == EnableOption:
            if opt.value == opt.enabled:
                printOpt("disable-" + opt.name, opt.help)
            else:
                printOpt("enable-" + opt.name, opt.help)
        else:
            sys.stderr.write("FATAL ERROR in help!\n")
            sys.exit(2)
    sys.exit(1)

processArguments(os.getcwd(), os.path.dirname(sys.argv[0]), sys.argv[1:])
